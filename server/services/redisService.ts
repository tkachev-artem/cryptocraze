import { createClient, RedisClientType } from 'redis';
import { EventEmitter } from 'events';

export interface PriceData {
  symbol: string;
  price: number;
  volume24h: number;
  priceChange24h: number;
  timestamp: number;
}

export class RedisService extends EventEmitter {
  private client: RedisClientType;
  private subscriber: RedisClientType;
  private publisher: RedisClientType;
  
  private readonly PRICE_KEY_PREFIX = 'price:';
  private readonly PRICE_CHANNEL_PREFIX = 'price_update:';
  private readonly CANDLE_KEY_PREFIX = 'candles:'; // key: candles:SYMBOL:INTERVAL
  
  constructor() {
    super();
    
    const redisUrl = process.env.REDIS_URL || 'redis://localhost:6379';
    
    // –û—Å–Ω–æ–≤–Ω–æ–π –∫–ª–∏–µ–Ω—Ç –¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–π
    this.client = createClient({ url: redisUrl });
    
    // –û—Ç–¥–µ–ª—å–Ω—ã–µ –∫–ª–∏–µ–Ω—Ç—ã –¥–ª—è pub/sub (—Ç—Ä–µ–±–æ–≤–∞–Ω–∏–µ Redis)
    this.subscriber = createClient({ url: redisUrl });
    this.publisher = createClient({ url: redisUrl });
    
    this.setupConnections();
  }

  private async setupConnections(): Promise<void> {
    try {
      await Promise.all([
        this.client.connect(),
        this.subscriber.connect(),
        this.publisher.connect()
      ]);
      
      console.log('‚úÖ Redis –ø–æ–¥–∫–ª—é—á–µ–Ω —É—Å–ø–µ—à–Ω–æ');
      
      // –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ –≤—Å–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ü–µ–Ω
      await this.subscriber.pSubscribe(`${this.PRICE_CHANNEL_PREFIX}*`, (message, channel) => {
        try {
          const symbol = channel.replace(this.PRICE_CHANNEL_PREFIX, '');
          const priceData: PriceData = JSON.parse(message);
          this.emit('priceUpdate', priceData);
        } catch (error) {
          console.error('–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è Redis:', error);
        }
      });
      
      console.log('üì° –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ Redis price updates –∞–∫—Ç–∏–≤–Ω–∞');
      
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ Redis:', error);
      // Fallback –±–µ–∑ Redis
      setTimeout(() => this.setupConnections(), 5000);
    }
  }

  /**
   * –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å–≤–µ—á–∏ –≤ Redis —Å TTL (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 60‚Äì120 —Å–µ–∫, —Å–ª—É—á–∞–π–Ω–æ)
   */
  async setCandles(symbol: string, interval: string, candles: any[], ttlSeconds?: number): Promise<void> {
    try {
      const upperSymbol = symbol.toUpperCase();
      const key = `${this.CANDLE_KEY_PREFIX}${upperSymbol}:${interval}`;
      const ttl = typeof ttlSeconds === 'number' && ttlSeconds > 0
        ? Math.floor(ttlSeconds)
        : 60 + Math.floor(Math.random() * 61); // 60..120 —Å–µ–∫
      await this.client.setEx(key, ttl, JSON.stringify(candles));
    } catch (error) {
      console.error(`–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–≤–µ—á–µ–π ${symbol} ${interval} –≤ Redis:`, error);
    }
  }

  /**
   * –ü–æ–ª—É—á–∏—Ç—å —Å–≤–µ—á–∏ –∏–∑ Redis –∫—ç—à–∞
   */
  async getCandles(symbol: string, interval: string): Promise<any[] | null> {
    try {
      const upperSymbol = symbol.toUpperCase();
      const key = `${this.CANDLE_KEY_PREFIX}${upperSymbol}:${interval}`;
      const data = await this.client.get(key);
      return data && typeof data === 'string' ? JSON.parse(data) : null;
    } catch (error) {
      console.error(`–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–≤–µ—á–µ–π ${symbol} ${interval} –∏–∑ Redis:`, error);
      return null;
    }
  }

  /**
   * –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ü–µ–Ω—É –≤ Redis –∏ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —á–µ—Ä–µ–∑ Pub/Sub
   */
  async setPrice(symbol: string, priceData: PriceData): Promise<void> {
    try {
      const key = `${this.PRICE_KEY_PREFIX}${symbol}`;
      const channel = `${this.PRICE_CHANNEL_PREFIX}${symbol}`;
      
      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∫—ç—à —Å TTL 1 —á–∞—Å
      await this.client.setEx(key, 3600, JSON.stringify(priceData));
      
      // –ü—É–±–ª–∏–∫—É–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–ª—è –≤—Å–µ—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤
      await this.publisher.publish(channel, JSON.stringify(priceData));
      
    } catch (error) {
      console.error(`–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ü–µ–Ω—ã ${symbol} –≤ Redis:`, error);
    }
  }

  /**
   * –ü–æ–ª—É—á–∏—Ç—å —Ü–µ–Ω—É –∏–∑ Redis –∫—ç—à–∞
   */
  async getPrice(symbol: string): Promise<PriceData | null> {
    try {
      const key = `${this.PRICE_KEY_PREFIX}${symbol}`;
      const data = await this.client.get(key);
      return data && typeof data === 'string' ? JSON.parse(data) : null;
    } catch (error) {
      console.error(`–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ü–µ–Ω—ã ${symbol} –∏–∑ Redis:`, error);
      return null;
    }
  }

  /**
   * –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ —Ü–µ–Ω—ã
   */
  async getAllPrices(): Promise<Record<string, PriceData>> {
    try {
      const keys = await this.client.keys(`${this.PRICE_KEY_PREFIX}*`);
      const prices: Record<string, PriceData> = {};
      
      for (const key of keys) {
        const symbol = key.replace(this.PRICE_KEY_PREFIX, '');
        const data = await this.client.get(key);
        if (data && typeof data === 'string') {
          prices[symbol] = JSON.parse(data);
        }
      }
      
      return prices;
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –≤—Å–µ—Ö —Ü–µ–Ω –∏–∑ Redis:', error);
      return {};
    }
  }

  /**
   * –ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π
   */
  async getStats(): Promise<{ totalPrices: number; redisConnected: boolean }> {
    try {
      const keys = await this.client.keys(`${this.PRICE_KEY_PREFIX}*`);
      return {
        totalPrices: keys.length,
        redisConnected: this.client.isReady && this.subscriber.isReady && this.publisher.isReady
      };
    } catch {
      return { totalPrices: 0, redisConnected: false };
    }
  }

  /**
   * –ë–∞—Ç—á–µ–≤–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –º–Ω–æ–∂–µ—Å—Ç–≤–∞ —Ü–µ–Ω
   */
  async setBatchPrices(prices: Record<string, PriceData>): Promise<void> {
    try {
      const pipeline = this.client.multi();
      
      for (const [symbol, priceData] of Object.entries(prices)) {
        const key = `${this.PRICE_KEY_PREFIX}${symbol}`;
        pipeline.setEx(key, 3600, JSON.stringify(priceData));
      }
      
      await pipeline.exec();
      
      // –ü—É–±–ª–∏–∫—É–µ–º –∫–∞–∂–¥—É—é —Ü–µ–Ω—É –æ—Ç–¥–µ–ª—å–Ω–æ (pub/sub –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç batch)
      for (const [symbol, priceData] of Object.entries(prices)) {
        const channel = `${this.PRICE_CHANNEL_PREFIX}${symbol}`;
        await this.publisher.publish(channel, JSON.stringify(priceData));
      }
      
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ –±–∞—Ç—á–µ–≤–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ü–µ–Ω:', error);
    }
  }

  /**
   * –ó–∞–∫—Ä—ã—Ç—å –≤—Å–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
   */
  async destroy(): Promise<void> {
    try {
      await Promise.all([
        this.client.quit(),
        this.subscriber.quit(),
        this.publisher.quit()
      ]);
      console.log('Redis —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –∑–∞–∫—Ä—ã—Ç—ã');
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ –∑–∞–∫—Ä—ã—Ç–∏—è Redis —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π:', error);
    }
  }
}

export const redisService = new RedisService();