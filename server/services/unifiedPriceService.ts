import { EventEmitter } from 'events';
import { BinanceApiService } from './binanceApi';
import { binanceWs } from './binanceWs';
import { redisService } from './redisService';

export interface PriceData {
  symbol: string;
  price: number;
  volume24h: number;
  priceChange24h: number;
  timestamp: number;
}

export interface CandlestickData {
  timestamp: number;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
}

export class UnifiedPriceService extends EventEmitter {
  private priceCache = new Map<string, PriceData>();
  private activePairs = new Set<string>();
  private priceInterval: NodeJS.Timeout | null = null;
  private statsInterval: NodeJS.Timeout | null = null;
  private binanceApi: BinanceApiService;
  
  // –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ç–æ—Ä–≥–æ–≤—ã–µ –ø–∞—Ä—ã
  private readonly supportedSymbols = new Set([
    'BTCUSDT', 'ETHUSDT', 'ADAUSDT', 'DOTUSDT', 'LINKUSDT', 
    'LTCUSDT', 'BCHUSDT', 'XLMUSDT', 'EOSUSDT', 'TRXUSDT',
    'BNBUSDT', 'XRPUSDT', 'SOLUSDT', 'MATICUSDT', 'AVAXUSDT'
  ]);

  constructor() {
    super();
    this.binanceApi = new BinanceApiService();
    this.startPriceUpdates();
    this.setupWsListener();
    this.setupRedisListener();
  }

  /**
   * –î–æ–±–∞–≤–∏—Ç—å —Ç–æ—Ä–≥–æ–≤—É—é –ø–∞—Ä—É –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è
   */
  async addPair(symbol: string): Promise<void> {
    const upperSymbol = symbol.toUpperCase();
    
    if (!this.supportedSymbols.has(upperSymbol)) {
      throw new Error(`–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º–∞—è —Ç–æ—Ä–≥–æ–≤–∞—è –ø–∞—Ä–∞: ${symbol}`);
    }
    
    this.activePairs.add(upperSymbol);
    // –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ –ø–æ—Ç–æ–∫ Binance WS
    await binanceWs.subscribe(upperSymbol);

    // –ü–æ–ª—É—á–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—É—é —Ü–µ–Ω—É
    try {
      const priceData = await this.fetchPrice(upperSymbol);
      this.priceCache.set(upperSymbol, priceData);
      this.emit('priceUpdate', priceData);
    // info: pair added
    } catch (error) {
      console.error(`‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –Ω–∞—á–∞–ª—å–Ω–æ–π —Ü–µ–Ω—ã –¥–ª—è ${upperSymbol}:`, error);
      throw error;
    }
  }

  /**
   * –£–¥–∞–ª–∏—Ç—å —Ç–æ—Ä–≥–æ–≤—É—é –ø–∞—Ä—É –∏–∑ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è
   */
  removePair(symbol: string): void {
    const upperSymbol = symbol.toUpperCase();
    this.activePairs.delete(upperSymbol);
    this.priceCache.delete(upperSymbol);
    binanceWs.unsubscribe(upperSymbol).catch(() => {});
    // info: pair removed
  }

  /**
   * –ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â—É—é —Ü–µ–Ω—É
   */
  getPrice(symbol: string): PriceData | undefined {
    const upperSymbol = symbol.toUpperCase();
    return this.priceCache.get(upperSymbol);
  }

  /**
   * –ü–æ–ª—É—á–∏—Ç—å —Ü–µ–Ω—É –∏–∑ Redis (–∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ)
   */
  async getPriceFromRedis(symbol: string): Promise<PriceData | null> {
    return await redisService.getPrice(symbol.toUpperCase());
  }

  /**
   * –ü–æ–ª—É—á–∏—Ç—å —Å–≤–µ—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
   */
  async getCandlestickData(symbol: string, interval: string, limit: number = 100): Promise<CandlestickData[]> {
    const upperSymbol = symbol.toUpperCase();
    
    if (!this.supportedSymbols.has(upperSymbol)) {
      throw new Error(`–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º–∞—è —Ç–æ—Ä–≥–æ–≤–∞—è –ø–∞—Ä–∞: ${symbol}`);
    }

    try {
      const candlesticks = await this.binanceApi.getCandlestickData(upperSymbol, interval, limit);
      
      // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –Ω–∞—à —Ñ–æ—Ä–º–∞—Ç
      return candlesticks.map(candle => ({
        timestamp: candle.openTime,
        open: candle.open,
        high: candle.high,
        low: candle.low,
        close: candle.close,
        volume: candle.volume
      }));
      
    } catch (error) {
      console.error(`‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–≤–µ—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –¥–ª—è ${upperSymbol}:`, error);
      throw error;
    }
  }

  /**
   * –ü–æ–ª—É—á–∏—Ç—å —Ü–µ–Ω—É —Å Binance API
   */
  private async fetchPrice(symbol: string): Promise<PriceData> {
    const upperSymbol = symbol.toUpperCase();
    
    try {
      // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â—É—é —Ü–µ–Ω—É
      const currentPrice = await this.binanceApi.getCurrentPrice(upperSymbol);
      
      // –ü–æ–ª—É—á–∞–µ–º 24-—á–∞—Å–æ–≤—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
      const stats24h = await this.binanceApi.get24hrStats(upperSymbol);
      
      return {
        symbol: upperSymbol,
        price: currentPrice,
        volume24h: stats24h.quoteVolume || 0,
        priceChange24h: stats24h.priceChangePercent || 0,
        timestamp: Date.now(),
      };
      
    } catch (error) {
      console.error(`‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ü–µ–Ω—ã –¥–ª—è ${upperSymbol}:`, error);
      
      // Fallback –¥–∞–Ω–Ω—ã–µ –ø—Ä–∏ –æ—à–∏–±–∫–µ
      return this.getFallbackPrice(upperSymbol);
    }
  }

  /**
   * Fallback –¥–∞–Ω–Ω—ã–µ –ø—Ä–∏ –æ—à–∏–±–∫–∞—Ö API
   */
  private getFallbackPrice(symbol: string): PriceData {
    const fallbackPrices: Record<string, number> = {
      'BTCUSDT': 116000 + Math.random() * 2000,
      'ETHUSDT': 3500 + Math.random() * 200,
      'ADAUSDT': 0.5 + Math.random() * 0.1,
      'DOTUSDT': 7 + Math.random() * 1,
      'LINKUSDT': 15 + Math.random() * 2,
      'LTCUSDT': 80 + Math.random() * 10,
      'BCHUSDT': 400 + Math.random() * 50,
      'XLMUSDT': 0.1 + Math.random() * 0.02,
      'EOSUSDT': 0.8 + Math.random() * 0.1,
      'TRXUSDT': 0.08 + Math.random() * 0.01,
      'BNBUSDT': 300 + Math.random() * 20,
      'XRPUSDT': 0.6 + Math.random() * 0.1,
      'SOLUSDT': 100 + Math.random() * 10,
      'MATICUSDT': 0.8 + Math.random() * 0.1,
      'AVAXUSDT': 30 + Math.random() * 3,
    };

    const basePrice = fallbackPrices[symbol] || 100;
    const volatility = 0.02; // 2% –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å
    const variation = basePrice * volatility * (Math.random() - 0.5);
    
    console.warn(`‚ö†Ô∏è –ò—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è fallback –¥–∞–Ω–Ω—ã–µ –¥–ª—è ${symbol}`);
    
    return {
      symbol,
      price: basePrice + variation,
      volume24h: basePrice * 1000000 * (0.5 + Math.random()),
      priceChange24h: (Math.random() - 0.5) * 10, // -5% to +5%
      timestamp: Date.now(),
    };
  }

  /**
   * –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ü–µ–Ω –¥–ª—è –≤—Å–µ—Ö –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–∞—Ä
   */
  private async updatePrices(): Promise<void> {
    if (this.activePairs.size === 0) {
      return;
    }

    const symbols = Array.from(this.activePairs);
    
    for (const symbol of symbols) {
      try {
        const priceData = await this.fetchPrice(symbol);
        this.priceCache.set(symbol, priceData);
        this.emit('priceUpdate', priceData);
      } catch (error) {
        console.error(`‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ü–µ–Ω—ã –¥–ª—è ${symbol}:`, error);
      }
    }
  }

  /**
   * –ó–∞–ø—É—Å–∫ –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ü–µ–Ω
   */
  private startPriceUpdates(): void {
    // REST —Ñ–æ–ª–±—ç–∫ —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –ø—Ä–æ–±–ª–µ–º–∞—Ö —Å WS (—Ä–µ–¥–∫–æ)
    this.priceInterval = setInterval(() => {
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –æ—Ç WS –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 2 –º–∏–Ω—É—Ç—ã
      const hasRecentWsData = Array.from(this.activePairs).some(symbol => {
        const data = this.priceCache.get(symbol);
        return data && (Date.now() - data.timestamp) < 120_000;
      });
      
      if (!hasRecentWsData) {
        console.log('‚ö†Ô∏è WS –Ω–µ–∞–∫—Ç–∏–≤–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º REST —Ñ–æ–ª–±—ç–∫');
        this.updatePrices();
      }
    }, 180_000); // –ø—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–µ 3 –º–∏–Ω—É—Ç—ã

    // 24h —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ä–µ–∂–µ –∏ —Å –±–∞—Ç—á–∏–Ω–≥–æ–º
    this.statsInterval = setInterval(async () => {
      const symbols = Array.from(this.activePairs);
      if (symbols.length === 0) return;
      
      // –ë–∞—Ç—á–∏–º –ø–æ 5 —Å–∏–º–≤–æ–ª–æ–≤ —Å –∑–∞–¥–µ—Ä–∂–∫–æ–π –¥–ª—è —Å–æ–±–ª—é–¥–µ–Ω–∏—è weight limits
      for (let i = 0; i < symbols.length; i += 5) {
        const batch = symbols.slice(i, i + 5);
        
        for (const symbol of batch) {
          try {
            const stats24h = await this.binanceApi.get24hrStats(symbol);
            const current = this.priceCache.get(symbol);
            if (current) {
              const updated = {
                ...current,
                volume24h: stats24h.quoteVolume || current.volume24h,
                priceChange24h: stats24h.priceChangePercent || current.priceChange24h,
              };
              this.priceCache.set(symbol, updated);
              // –ù–ï —ç–º–∏—Ç–∏–º priceUpdate –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏, —Ç–æ–ª—å–∫–æ –¥–ª—è —Ü–µ–Ω
            }
          } catch (error) {
            console.warn(`–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –¥–ª—è ${symbol}`);
          }
        }
        
        // –ü–∞—É–∑–∞ –º–µ–∂–¥—É –±–∞—Ç—á–∞–º–∏
        if (i + 5 < symbols.length) {
          await new Promise(resolve => setTimeout(resolve, 2000));
        }
      }
    }, 300_000); // –∫–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç

    console.log('üìä –ó–∞–ø—É—â–µ–Ω—ã —Ç–∞–π–º–µ—Ä—ã: REST —Ñ–æ–ª–±—ç–∫ (3 –º–∏–Ω), —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ (5 –º–∏–Ω)');
  }

  /**
   * –û—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–µ—Ä–≤–∏—Å–∞
   */
  destroy(): void {
    if (this.priceInterval) {
      clearInterval(this.priceInterval);
      this.priceInterval = null;
    }
    if (this.statsInterval) {
      clearInterval(this.statsInterval);
      this.statsInterval = null;
    }
    this.priceCache.clear();
    this.activePairs.clear();
    // info: price service stopped
  }

  private setupWsListener(): void {
    // –ü–æ–ª—É—á–∞–µ–º —Ç–∏–∫–∏ –∏–∑ Binance WS –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ Redis
    binanceWs.on('price', async ({ symbol, price, exchangeTimestamp }) => {
      if (!this.activePairs.has(symbol)) return;
      
      const prev = this.priceCache.get(symbol);
      const updated: PriceData = {
        symbol,
        price,
        volume24h: prev?.volume24h ?? 0,
        priceChange24h: prev?.priceChange24h ?? 0,
        timestamp: exchangeTimestamp || Date.now(),
      };
      
      // –û–±–Ω–æ–≤–ª—è–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–π –∫—ç—à
      this.priceCache.set(symbol, updated);
      
      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ Redis –¥–ª—è –¥–∏—Å—Ç—Ä–∏–±—É—Ü–∏–∏ –º–µ–∂–¥—É –ø—Ä–æ—Ü–µ—Å—Å–∞–º–∏
      await redisService.setPrice(symbol, updated);
      
      // –õ–æ–∫–∞–ª—å–Ω–æ–µ —Å–æ–±—ã—Ç–∏–µ (–¥–ª—è backwards compatibility)
      this.emit('priceUpdate', updated);
    });
  }

  private setupRedisListener(): void {
    // –ü–æ–ª—É—á–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∏–∑ Redis –æ—Ç –¥—Ä—É–≥–∏—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤
    redisService.on('priceUpdate', (priceData: PriceData) => {
      // –û–±–Ω–æ–≤–ª—è–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–π –∫—ç—à
      this.priceCache.set(priceData.symbol, priceData);
      
      // –≠–º–∏—Ç–∏–º —Å–æ–±—ã—Ç–∏–µ –¥–ª—è Socket.io
      this.emit('priceUpdate', priceData);
    });
  }
}

// –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä
export const unifiedPriceService = new UnifiedPriceService(); 